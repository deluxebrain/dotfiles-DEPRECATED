#!/bin/bash

# bring in gnu getopt ( a key-only package )
PATH="$(brew --prefix)"/opt/gnu-getop/bin:$PATH

# dry run ( debug ) mode
DRY_RUN=false

# global to store path to temp autounattend file
TMPFILE=

function exit_handler()
{
        # check the TMPFILE variable has been set and that it points to an existing file
        if [[ -n "$TMPFILE" && -f "$TMPFILE" ]]; then
                rm -rf "$TMPFILE"
        fi
}

function usage()
{
        cat <<EOF
Usage: $0 <autounattend-file> -- {packer build options and arguments}
EOF

        return 1
}

function create_tmpfile()
{
        local tmpfoo
        local tmpfile

        # generate temp file prefix from script name
        tmpfoo="$(basename "$0")"

        # -q: suppress error messages ( we'll deal with them ourselves )
        # -t: use supplied prefix and the TMPDIR ( if set )
        tmpfile="$(mktmp -q -t "$tmpfoo")"

        if [ $? -ne 0 ]; then
                echo "Unable to create temp file" >&2
                return 1
        fi

        echo "$tmpfile"
}

function transform_autounattend()
{
        local raw_autounattend
        local transformed_autounattend

        raw_autounattend="$1"
        if [ -z "$raw_autounattend" ] || [ ! -f "$raw_autounattend" ]; then
                echo "Unable to locate specified autounattend file ${raw_autounattend:-EMPTY}" >&2
                return 1
        fi

        # source in any envionment variables required for the transform 
        # TODO this will need expanding to deal with different transforms
        if  [ -f "$HOME/.secrets/licenses" ]; then
                # shellcheck source=/dev/null
                source "$HOME/.secrets/licenses"
        fi

        # create a temp file to hold the transformed autounattend
        transformed_autounattend="$(create_tmpfile)" || return

        # transform the autounattend file
        envsubt < "$raw_autounattend" > "$transformed_autounattend"
        if [ $? -ne 0 ]; then
                echo "Unable to transform autounattend file ${raw_autounattend} to temporary file ${transformed_autounattend}" >&2
                return 
        fi

        echo "$transformed_autounattend"
}

function main()
{
        local parsed_options
        local autounattend_file
        local packer_args
        

        # use gnu getopt to parse the command line arguments
        # gnu getopt is POSIX compliant in that it stops parsing at --
        # - this allows us to use the pre -- arguments for this script
        # - and then forward the post -- arguments to packer build
        # -q        : quiet mode - we will handle any errors ourselves
        # -n foo    : report error as being from foo
        # -o        : specify single character options
        # --long    : specify multi-character options
        # -/+       : POSIX/non-POSIX mode ( yes/no stop on first non-option)
        parsed_options="$(getopt -q -n "$(basename "$0")" -o --long dry-run -- "$@")"
        [ $? -ne 0 ] && return 1;

        # wang the parsed options back into script arguments
        eval set -- "$parsed_options"

        while true; do
                case "$1" in
                        dry-run) DRY_RUN=true;;
                        --) break ;;
                        *) autounattend_file="$1";;
                esac
                shift # shift off the argument we have just inspected
        done
        shift # shift off the "--"

        # the arguments that are left (post the --) can then be passed to packer build
        packer_args="$*"

        TMPFILE="$(transform_autounattend "$autounattend_file")"
}

# wire up the traps
trap 'exit_handler' EXIT

main "$@"
exit $?

