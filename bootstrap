#!/bin/bash
#
# bootstrap the dotfiles setup

# TODO
# 4. Move to msg_
# 5. Deal with symlinking non dotfiles

set -o errtrace	  # inherit ERR traps within functions, substs and subshells
set -o pipefail	  # fail entire pipeline
set -o nounset	  # exit on any attempt to use uninitialized variables
set -o errexit	  # exit the script if any statement returns non-true

# Rather than using relative paths just cd into the script directory
# This works better for linting as well
_SCRIPT_PATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$_SCRIPT_PATH" || exit 1

# Bring in the core library and enable global error handler
# No futher need to check return codes after this point ...
source ./lib/core.sh || exit 1
USE_GLOBAL_ERROR_HANDLER

function path_exists() 
{
	local path
	path="$1"

	# check if paths  exists (in one of various forms)
	# [[		: Allow for construction of complex expressions ( use of && and grouping )
	# -n		: string has non-zero length
	# -o 		: OR the conditions together
	# -f 		: file exists
	# -d		: file exists and is a directory
	# -L		: file exists and is a symlink
	[[ -n "$path" && (-f "$path"|| -d "$path" || -L "$path" ) ]]
}

function deal_with_existing_destination_path()
{
	local src
	local dst

	src="$1"
	dst="$2"

	if /
		! $g_overwrite_all && /
		! $g_backup_all && /
		! $g_skip_all; then
		# global strategy in place
		# no more action required
		return 0
	fi

	if dst_points_to_src "$src" "$dst"; then
		# destination points to source
		# skip current file
		g_skip=true;
		return 0
	fi
	
	# user intervention required
	prompt_for_file_overwrite_action "$src" "$dst"
}

function dst_points_to_src() 
{
	local src
	local dst
	local target

	src="$1"
	dst="$2"

	# check if dst is a symlink that points to src
	# readlink returns blank and error if not a symlink 
	target="$(readlink $"dst")"
	[ "$target" == "$src" ]
}

function prompt_for_file_overwrite_action() 
{
	local src
	local dst
	local action

	src="$1"
	dst="$2"

	# -e : Enable interpretation of bashslash escapes ( to get the newline )
	echo -e \
		"File already exists: $dst $(basename "$src"); what do you want todo?\n"\
		"[s]kip, [S]kip all, [o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all?"

	# read one byte into action 
	# -r	: raw mode to prevent \ getting messed up
	# -n x	: read x bytes
	read -r -n 1 action

	case "$action" in
	  o)
	    g_overwrite=true
	    ;;
	  O)
	    g_overwrite_all=true
	    ;;
	  b) 
	    g_backup=true
	    ;;
	  B)
	    g_backup_all=true
	    ;;
	  s)
	    g_skip=true
	    ;;
	  S)
	    g_skip_all=true
	    ;;
	  *)
	    ;;
	esac	
}

function link_file() 
{
	local src dst 
	# Visible to all functions in the stack
	local overwrite	      # Per file action 
	local backup	      # Per file action
	local backup_path     # Per back path
	
	src="$1"
	dst="$2"

	# quasi-booleans ...
	# true / false are just strings, but will be "evaluated" as commands in conditionals
	overwrite=false 
	backup=false 

	echo "Linking source path ${src} to destination path ${path} ..."

	# work out what todo when source points to an existing destination
	if path_exists "$dst"; then
		
		deal_with_existing_destination_path "$src" "$dst"

		# quasi-booleans ...
		# Note the variables are NOT surrounded by quotes
		# Hence they will be evaluated as commands
		# Note it is possible to form complex expressions
		if $g_overwrite || $overwrite; then
			echo "removing $dst ..."
			DEBUG rm -rf "$dst"
		elif $g_backup || $backup; then
			backup_path="$(file_backup_strategy "$dst")"
			echo "backing up $dst to $backup_path ..." 
			DEBUG mv "$dst" "$backup_path"
		else
			echo "skipping $src"
			return 0;
		fi
	fi

	# link target to point at source
	# -s	: create a symbolic link
	# -f	: unlink the target if it exists
	# -n	: if target is already a symlink, dont follow it
	echo "linking $src to $dst ..." 
	DEBUG ln -sfn "$src" "$dst" 
}

function file_backup_strategy() 
{
	local path
	
	path="$1"
	echo "${path}.backup"
}

function form_link_path()
{
	local src

	src="$1"
	
	# ${string%substring} : Deletes shortest match of $substring from back of $string
	echo "$HOME/.$(basename "${src%.symlink}")"
}

function install_dotfiles() 
{
	local src dst
	# Visible to all functions in the stack
	local overwrite_all
	local backup_all
	local skip_all
	
	overwrite_all=false 
	backup_all=false 
	skip_all=false

	echo "Installing dotfiles ..."
	# Find:
	# -H  : For symlinks use the file info of the linked file
	# Exclude .git directories
	echo "Looking for files and directories to link within ${_SCRIPT_PATH} ..."
	find -H "$_SCRIPT_PATH" -maxdepth 3 -name '*.symlink' -not -path '*.git*' | while -r read src
	do
		dst="$(form_link_path "$src")"
		link_file "$src" "$dst"
	done
}

function install_prequisites()
{
	echo "Installing prerequisites"

	# Ensure xcode command line tools are installed
	echo "Installing XCode CLI tools if they are missing ..."
	sudo xcode-select --install
}

function install_packages()
{
	echo "Installing packages ..."
}

function main() 
{
	install_prequisites && \
		install_dotfiles && \
		install_packages
}

main 
exit $?

