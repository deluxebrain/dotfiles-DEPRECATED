#!/bin/bash
#
# bootstrap the dotfiles setup

set -o errtrace	  # inherit ERR traps within functions, substs and subshells
set -o pipefail	  # fail entire pipeline
set -o nounset	  # exit on any attempt to use uninitialized variables
set -o errexit	  # exit the script if any statement returns non-true

# Wire up temporary named pipe to store stderr for use in ERR trap
ERR_PIPE="$(mktemp -u)"
mkfifo "${ERR_PIPE}"

# Redirect file descriptor 3 to stdout
# Tee stdout to named pipe, then get stderr to fd 3 
exec 3>&1
exec > >(tee "${ERR_PIPE}") 2>&1 1>&3

# Wire up ERR and EXIT traps
trap 'trap_err ${LINENO} $?' ERR
trap 'trap_exit' EXIT

function trap_err()
{
	local message
	local code

	message="$(head -n1 < "${ERR_PIPE}")"
	code=${2:-1}
	echo "${code}>Error on line $1: ${message}"
	exit ${code}
}

function trap_exit()
{
	# Clean up the named pipe
	rm "${ERR_PIPE}"
	exec 3>&-
}

function path_exists() 
{
	local path
	path="$1"

	# check if paths  exists (in one of various forms)
	# note a function that ends without an explcit return statement
	# returns the exit code of the last executed command
	#  [		: Test with pathname expansion (as opposed to [[)
	# -n		: string has non-zero length
	# -o 		: OR the conditions together
	# -f 		: file exists
	# -d		: file exists and is a directory
	# -L		: file exists and is a symlink
	[ -n "$path" ] && [ -f "$path" -o -d "$path" -o -L "$path" ] 
}

function deal_with_existing_file()
{
	local src
	local dst

	src="$1"
	dst="$2"

	if /
		[ "$g_overwrite_all" == false ] && /
		[ "$g_backup_all" == false ] && /
		[ "$g_skip_all" == false ]; then
		# global strategy in place
		# no more action required
		return 0
	fi

	if dst_points_to_src "${src}" "${dst}"; then
		# destination points to source
		# skip current file
		g_skip=true;
		return 0
	fi
	
	# user intervention required
	prompt_for_file_overwrite_action "${src}" "${dst}"
}

function dst_points_to_src() 
{
	local src
	local dst
	local target

	src="$1"
	dst="$2"

	# check if dst is a symlink that points to src
	# readlink returns blank and error if not a symlink 
	target="$(readlink $"dst")"
	[ "$target" == "$src" ]
}

function prompt_for_file_overwrite_action() 
{
	local src
	local dst
	local action

	src="$1"
	dst="$2"

	# -e : Enable interpretation of bashslash escapes ( to get the newline )
	echo -e \
		"File already exists: ${dst} $(basename $src); what do you want todo?\n"\
		"[s]kip, [S]kip all, [o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all?"

	# read one byte into action 
	read -n 1 action

	case "${action}" in
	  o)
	    g_overwrite=true
	    ;;
	  O)
	    g_overwrite_all=true
	    ;;
	  b) 
	    g_backup=true
	    ;;
	  B)
	    g_backup_all=true
	    ;;
	  s)
	    g_skip=true
	    ;;
	  S)
	    g_skip_all=true
	    ;;
	  *)
	    ;;
	esac	
}

function link_file() 
{
	local src dst overwrite backup backup_path
	
	src="$1"
	dst="$2"

	# These are going to be global to the execution of the script ( g_ )
	g_overwrite=false 
	g_backup=false 

	# work out what todo when source points to an existing destination
	if path_exists "${dst}"; then
		
		deal_with_existing_file "${src}" "${dst}"

		if [[ "${g_overwrite}" || "${overwrite}" ]]; then
			echo "removing ${dst}"
			rm -rf "${dst}"
			echo "removed ${dst}"
		elif [[ "$g_backup" || "$backup" ]]; then
			backup_path=$(file_backup_strategy "$dst")
			echo "backing up $dst to $backup_path" 
			mv "$dst" "$backup_path"
			echo "moved $dst to $backup_path"
		else
			echo "skipping $src"
			return 0;
		fi
	fi

	# link target to point at source
	# -s	: create a symbolic link
	# -f	: unlink the target if it exists
	# -n	: if target is already a symlink, dont follow it
	echo "linking $src to $dst" 
	ln -sfn
	echo "linked $src to $dst"
}

function file_backup_strategy() 
{
	local path
	
	path="$1"
	echo "${dst}.backup"
}

function link_dotfiles() 
{
	g_overwrite_all=false 
	backup_all=false 
	skip_all=false

	info_msg "linking dotfiles ..."
}

function main() 
{
	# Ensure xcode command line tools are installed
	sudo xcode-select --install

}

main 
exit $?

