#!/bin/bash
#
# bootstrap the dotfiles setup

set -o errtrace	  # inherit ERR traps within functions, substs and subshells
set -o pipefail	  # fail entire pipeline
set -o nounset	  # exit on any attempt to use uninitialized variables
set -o errexit	  # exit the script if any statement returns non-true

_ERR_PIPE="$(mktemp -u)"
_DEBUG=true

# Wire up temporary named pipe to store stderr for use in ERR trap
mkfifo "$_ERR_PIPE"

# Redirect file descriptor 3 to stdout
# Tee stdout to named pipe, then get stderr to fd 3 
exec 3>&1
exec > >(tee "$_ERR_PIPE") 2>&1 1>&3

# Wire up ERR and EXIT traps
trap 'trap_err $LINENO $?' ERR
trap 'trap_exit' EXIT

function trap_err()
{
	local message
	local code

	message="$(head -n1 < "$_ERR_PIPE")"
	code="${2:-1}"
	echo "${code}>Error on line $1: $message"
	exit "$code"
}

function trap_exit()
{
	# Clean up the named pipe
	rm "$ERR_PIPE"
	exec 3>&-
}

function DEBUG()
{
	if $_DEBUG; then
		echo "[DEBUG] $@"
	else
		set -x
		$@
		set +x
	fi 
}

function path_exists() 
{
	local path
	path="$1"

	# check if paths  exists (in one of various forms)
	# [[		: Allow for construction of complex expressions ( use of && and grouping )
	# -n		: string has non-zero length
	# -o 		: OR the conditions together
	# -f 		: file exists
	# -d		: file exists and is a directory
	# -L		: file exists and is a symlink
	[[ -n "$path" && (-f "$path"|| -d "$path" ||-L "$path" ) ]]
}

function deal_with_existing_file()
{
	local src
	local dst

	src="$1"
	dst="$2"

	if /
		! $g_overwrite_all && /
		! $g_backup_all && /
		! $g_skip_all; then
		# global strategy in place
		# no more action required
		return 0
	fi

	if dst_points_to_src "$src" "$dst"; then
		# destination points to source
		# skip current file
		g_skip=true;
		return 0
	fi
	
	# user intervention required
	prompt_for_file_overwrite_action "$src" "$dst"
}

function dst_points_to_src() 
{
	local src
	local dst
	local target

	src="$1"
	dst="$2"

	# check if dst is a symlink that points to src
	# readlink returns blank and error if not a symlink 
	target="$(readlink $"dst")"
	[ "$target" == "$src" ]
}

function prompt_for_file_overwrite_action() 
{
	local src
	local dst
	local action

	src="$1"
	dst="$2"

	# -e : Enable interpretation of bashslash escapes ( to get the newline )
	echo -e \
		"File already exists: $dst $(basename "$src"); what do you want todo?\n"\
		"[s]kip, [S]kip all, [o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all?"

	# read one byte into action 
	# -r	: raw mode to prevent \ getting messed up
	# -n x	: read x bytes
	read -r -n 1 action

	case "$action" in
	  o)
	    g_overwrite=true
	    ;;
	  O)
	    g_overwrite_all=true
	    ;;
	  b) 
	    g_backup=true
	    ;;
	  B)
	    g_backup_all=true
	    ;;
	  s)
	    g_skip=true
	    ;;
	  S)
	    g_skip_all=true
	    ;;
	  *)
	    ;;
	esac	
}

function link_file() 
{
	local src dst 
	# Visible to all functions in the stack
	local overwrite	      # Per file action 
	local backup	      # Per file action
	local backup_path     # Per back path
	
	src="$1"
	dst="$2"

	# quasi-booleans ...
	# true / false are just strings, but ...
	overwrite=false 
	backup=false 

	# work out what todo when source points to an existing destination
	if path_exists "$dst"; then
		
		deal_with_existing_file "$src" "$dst"

		# quasi-booleans ...
		# Note the variables are NOT surrounded by quotes
		# Hence they will be evaluated as commands
		# Note it is possible to form complex expressions
		if $g_overwrite || $overwrite; then
			echo "removing $dst ..."
			DEBUG rm -rf "$dst"
		elif $g_backup || $backup; then
			backup_path="$(file_backup_strategy "$dst")"
			echo "backing up $dst to $backup_path ..." 
			DEBUG mv "$dst" "$backup_path"
		else
			echo "skipping $src"
			return 0;
		fi
	fi

	# link target to point at source
	# -s	: create a symbolic link
	# -f	: unlink the target if it exists
	# -n	: if target is already a symlink, dont follow it
	echo "linking $src to $dst ..." 
	DEBUG ln -sfn "$src" "$dst" 
}

function file_backup_strategy() 
{
	local path
	
	path="$1"
	echo "${dst}.backup"
}

function link_dotfiles() 
{
	g_overwrite_all=false 
	backup_all=false 
	skip_all=false

	info_msg "linking dotfiles ..."
}

function main() 
{
	# Ensure xcode command line tools are installed
	sudo xcode-select --install

}

main 
exit $?

